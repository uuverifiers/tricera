
get-1.c
Warning: no definition of function "non_det_int" available
Warning: no definition of function "non_det_int_ptr" available

Inferred ACSL annotations
================================================================================
/* contract for get */
/*@
  requires n == p && n_init >= 1 && \valid(p);
  ensures n == \old(p) && \old(n_init) == n_init && \old(r1) == r1 && \old(n) == \old(p) && n_init >= 1 && \result >= 0 && \valid(p) && (n_init == \result || 0 >= \result);
*/
================================================================================

SAFE

incdec-1.c
Warning: no definition of function "non_det_int" available
Warning: no definition of function "non_det_int_ptr" available

Inferred ACSL annotations
================================================================================
/* contract for decrement */
/*@
  requires \separated(a, val) && \separated(a, b) && \valid(val) && \valid(b) && \valid(a);
  ensures \old(b) == b && \old(a) == a && \old(b_init) == b_init && \old(a_init) == a_init && \separated(a, val) && \separated(a, b) && \valid(val) && \valid(b) && \valid(a) && \old(*val) - *val == 1;
*/
/* contract for increment */
/*@
  requires a == val && \separated(val, b) && \valid(b) && \valid(val);
  ensures \old(b) == b && \old(a) == \old(val) && \old(b_init) == b_init && \old(a_init) == a_init && a == \old(val) && \separated(val, b) && \valid(b) && \valid(val) && \old(*val) - *val == -1;
*/
================================================================================

SAFE

incdec-2.c
Warning: no definition of function "non_det_int" available
Warning: no definition of function "non_det_int_ptr" available

Inferred ACSL annotations
================================================================================
/* contract for decrement */
/*@
  requires \valid(val) && \valid(a);
  ensures \old(a) == a && \old(a_init) == a_init && \valid(val) && \valid(a) && \old(*val) - *val == 1;
*/
/* contract for increment */
/*@
  requires a == val && \valid(val);
  ensures \old(a) == \old(val) && \old(a_init) == a_init && a == \old(val) && \valid(val) && \old(*val) - *val == -1;
*/
================================================================================

SAFE

max-1.c
Warning: no definition of function "non_det_int" available
Warning: no definition of function "non_det_int_ptr" available

Inferred ACSL annotations
================================================================================
/* contract for findMax */
/*@
  requires b == y && a == x && \separated(x, y) && \valid(y) && \valid(x);
  ensures b == \old(y) && a == \old(x) && \old(b_init) == b_init && \old(a_init) == a_init && \old(r) == r && \old(b) == \old(y) && \old(a) == \old(x) && \separated(x, y) && \valid(y) && \valid(x) && ((b_init == \result && \result - a_init >= 1) || (\result == a_init && a_init >= b_init));
*/
================================================================================

SAFE

max-2.c
Warning: no definition of function "non_det_int_ptr" available
Warning: no definition of function "non_det_int" available

Inferred ACSL annotations
================================================================================
/* contract for findMax */
/*@
  requires b == y && a == x && r == max && \separated(y, max) && \separated(x, y) && \separated(x, max) && \valid(y) && \valid(x) && \valid(max);
  ensures b_init == \old(b_init) && a_init == \old(a_init) && \old(max) == r && \old(y) == b && \old(x) == a && \old(b) == b && \old(a) == a && \old(r) == r && \separated(b, r) && \separated(a, b) && \separated(a, r) && \valid(b) && \valid(a) && \valid(r);
*/
================================================================================

SAFE

multadd-1.c
Warning: no definition of function "non_det_int_ptr" available
Warning: no definition of function "non_det_int" available

Inferred ACSL annotations
================================================================================
/* contract for addTwoNumbers */
/*@
  requires \separated(b, result) && \separated(a, result) && \separated(a, b) && \valid(result) && \valid(b) && \valid(a);
  ensures \old(b_init) == b_init && \old(a_init) == a_init && \old(result) == result && \old(b) == b && \old(a) == a && \separated(b, result) && \separated(a, result) && \separated(a, b) && \valid(result) && \valid(b) && \valid(a) && \old(*b) + \old(*a) - *result == 0;
*/
/* contract for multiplyByTwo */
/*@
  requires a == num && \separated(b, result) && \separated(num, result) && \separated(num, b) && \valid(result) && \valid(b) && \valid(num);
  ensures \old(b_init) == b_init && \old(a_init) == a_init && \old(result) == result && \old(b) == b && \old(a) == \old(num) && a == \old(num) && \separated(b, result) && \separated(num, result) && \separated(num, b) && \valid(result) && \valid(b) && \valid(num) && 2*\old(*num) == *num;
*/
================================================================================

SAFE

truck-2.c

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Init:
                                                             main21_1(emptyHeap, 0, 0, 0, emptyHeap, 0, 0, 0)                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                                     |                                                                                     
                                                                                     |                                                                                     
                                                                                     V                                                                                     
 main46_22(newHeap(alloc(newHeap(alloc(newHeap(alloc(emptyHeap, O_Truck(Truck(5, nthAddr(3))))), O_Human(Human(2)))), O_Human(Human(3)))), 2, 3, 5, emptyHeap, 0, 0, 0, 1) 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Final:
 main46_22(newHeap(alloc(newHeap(alloc(newHeap(alloc(emptyHeap, O_Truck(Truck(5, nthAddr(3))))), O_Human(Human(2)))), O_Human(Human(3)))), 2, 3, 5, emptyHeap, 0, 0, 0, 1) 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Failed assertion:

UNSAFE

heapptr-to-stackptr.c

Inferred ACSL annotations
================================================================================
/* contract for swap */
/*@
  requires \true;
  ensures \valid(y) && \valid(x) && *x == \old(*y) && \old(*x) == *y;
*/
================================================================================

SAFE

qualified-heapptr-to-stackptr.c
tricera.concurrency.ccreader.CCExceptions$TranslationException: Type qualified pointers are currently not supported: tricera.concurrency.concurrent_c.Absyn.PointQualPoint@9f9
(error "Type qualified pointers are currently not supported: tricera.concurrency.concurrent_c.Absyn.PointQualPoint@9f9")
Other Error: Type qualified pointers are currently not supported: tricera.concurrency.concurrent_c.Absyn.PointQualPoint@9f9

multi-arg-1.c

Inferred ACSL annotations
================================================================================
/* contract for mod */
/*@
  requires \separated(t1, t2) && \valid(t2) && \valid(t1);
  ensures \separated(t1, t2) && \valid(t2) && \valid(t1) && \old(*t1) - *t1 == -1 && \old(*t2) - *t2 == 1;
*/
================================================================================

SAFE

multi-arg-2.c

Inferred ACSL annotations
================================================================================
/* contract for mod */
/*@
  requires \separated(t3, t4) && \separated(t2, t4) && \separated(t2, t3) && \separated(t1, t4) && \separated(t1, t3) && \separated(t1, t2) && \valid(t4) && \valid(t3) && \valid(t2) && \valid(t1);
  ensures \separated(t3, t4) && \separated(t2, t4) && \separated(t2, t3) && \separated(t1, t4) && \separated(t1, t3) && \separated(t1, t2) && \valid(t4) && \valid(t3) && \valid(t2) && \valid(t1) && 2*\old(*t3) == *t3 && \old(*t2) - *t2 == 1 && *t1 - \old(*t1) == 2 && 2*\old(*t1) - *t4 == -4;
*/
================================================================================

SAFE
